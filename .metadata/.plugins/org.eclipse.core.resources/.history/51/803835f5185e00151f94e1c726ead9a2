package exactChange;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import common.Helper;

public final class ExactChangeModel {

	private static final int numThreads = 3;

	private Object solutionUpdateLock;
	private float bestCost;
	private int[] bestDenominations;
	
	ExactChangeModel() {
		bestCost = Helper.INF;
		solutionUpdateLock = new Object();
	}
	
	public void offerNewSolution(int[] denominations, float cost){
		synchronized (solutionUpdateLock) {
			if(cost<bestCost){
				bestCost = cost;
				bestDenominations = denominations;
			}
		}
	}

	public static void main(String[] args) {
		int N = Integer.parseInt(args[0]);
		ExactChangeModel solver = new ExactChangeModel();

		List<ExactChangeRunner> threadPool = new ArrayList<ExactChangeRunner>();

		for (int threadNum = 0; threadNum < numThreads; threadNum++) {
			ExactChangeRunner runner = new ExactChangeRunner(solver, N);
			threadPool.execute(runner);
		}
		
		Timer timer = new Timer();
		TimerTask collectBestSolutionFromAllThreads = new SolutionCollector();
		timer.schedule(collectBestSolutionFromAllThreads, 115*1000*1000);
	}
	
	public class SolutionCollector extends TimerTask{

		public public SolutionCollector() {
			
		}
		
		@Override
		public void run() {
			// TODO Auto-generated method stub
			
		}
		
	}

	public int[] getStartingDenominations() {
		Random random = new Random();
		//generate multiples of 5
		return new int[] { 1, (random.nextInt(48) + 1) * 5,
				(random.nextInt(48) + 1) * 5, (random.nextInt(48) + 1) * 5,
				(random.nextInt(48) + 1) * 5, (random.nextInt(48) + 1) * 5,
				(random.nextInt(48) + 1) * 5 };
	}
}
