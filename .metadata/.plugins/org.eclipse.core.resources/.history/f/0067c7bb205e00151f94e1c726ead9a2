package common;

import exactChange.ExactChangeCalculator;

public class SolutionOptimizer extends Thread {

	private ParallelSolutionFinder model;

	private int N;
	
	private Object denominationUpdateLock;
	private int[] bestDenominations;
	private float bestCost;
	
	SolutionOptimizer(ParallelSolutionFinder model, int N) {
		this.model = model;
		this.N = N;
		denominationUpdateLock = new Object();
	}

	@Override
	public void run() {
		int[] startingDenominations = model.getStartingDenominations();
		float startingCost = ExactChangeCalculator.getCost(startingDenominations, N);
		setBestSolution(startingDenominations, startingCost);

		// TODO: make configurable
		optimizeTillConvergence(0.004f);
	}

	// optimize till gain is above threshold
	private void setBestSolution(int[] startingDenominations, float startingCost) {
		// TODO Auto-generated method stub
		
	}

	private void optimizeTillConvergence(final float minGainToRun) {

		bestCostTillNow = ExactChangeCalculator.getCost(
				bestDenominations, N);

		while (true) {
			int[] newDenominations = takeStep();
			float newCost = ExactChangeCalculator.getCost(newDenominations, N);
			float delta = bestCostTillNow-delta;
			offerNewSolution(newCost,newDenominations)
			
			if(delta<minGainToRun){
				
			}
			setBestDenominations(newDenominations);
			newDenominations = takeStep();
			calci.resetCosts();
			calci.calculateCostsForDenominations(newDenominations);
			newCost = calci.getCostGivenN(N);
			delta = bestCostTillNow - newCost;
		}
	}

	private int[] takeStep() {
		int[] newDenom = bestDenominations.clone();

		return newDenom;
	}
}
