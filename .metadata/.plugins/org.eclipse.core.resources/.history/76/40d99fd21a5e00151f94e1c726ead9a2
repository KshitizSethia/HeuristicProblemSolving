package exactChange;

import common.ParallelSolutionFinder;

public class SolutionOptimizer extends Thread {

	private ParallelSolutionFinder model;
	
	private int[] bestDenominations;
	private int N;
	private Object denominationUpdateLock;

	SolutionOptimizer(ParallelSolutionFinder model, int N) {
		this.model = model;
		this.N = N;
		denominationUpdateLock = new Object();
	}

	public int[] getBestDenominations() {
		synchronized (denominationUpdateLock) {
			return bestDenominations;
		}
	}

	public void setBestDenominations(int[] bestDenominations) {
		synchronized (denominationUpdateLock) {
			this.bestDenominations = bestDenominations;
		}
	}

	public getCost(){
		
	}
	
	@Override
	public void run() {
		setBestDenominations(model.getStartingDenominations());

		// TODO: make configurable
		optimizeTillConvergence(0.004f);
	}

	// optimize till gain is above threshold
	private void optimizeTillConvergence(final float minDeltaToRun) {
		ExactChangeCalculator calci = new ExactChangeCalculator();
		calci.calculateCostsForDenominations(bestDenominations);
		float bestCostTillNow = calci.getCostGivenN(N);

		int[] newDenominations = takeStep();
		calci.resetCosts();
		calci.calculateCostsForDenominations(newDenominations);
		float newCost = calci.getCostGivenN(N);
		float delta = bestCostTillNow - newCost;
		while (delta > minDeltaToRun) {
			bestCostTillNow = newCost;
			setBestDenominations(newDenominations);
			newDenominations = takeStep();
			calci.resetCosts();
			calci.calculateCostsForDenominations(newDenominations);
			newCost = calci.getCostGivenN(N);
			delta = bestCostTillNow - newCost;
		}
	}

	private int[] takeStep() {
		int[] newDenom = bestDenominations.clone();

		return newDenom;
	}
}
