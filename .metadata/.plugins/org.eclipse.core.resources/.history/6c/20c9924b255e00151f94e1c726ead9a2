package common;

import java.io.ObjectInputStream.GetField;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public final class ParallelSolutionFinder {

	private static final int numThreads = 3;

	private Object solutionUpdateLock;
	private float bestCost;
	private int[] bestDenominations;

	ParallelSolutionFinder() {
		bestCost = Helper.INF;
		solutionUpdateLock = new Object();
	}

	public void offerNewSolution(int[] denominations, float cost) {
		synchronized (solutionUpdateLock) {
			if (cost < bestCost) {
				bestCost = cost;
				bestDenominations = denominations;
			}
		}
	}
	
	private int[] getBestDenominations(){
		synchronized (solutionUpdateLock) {
			return bestDenominations.clone();
		}
	}

	public int[] getStartingDenominations() {
		Random random = new Random();
		// generate multiples of 5
		return new int[] { 1, (random.nextInt(48) + 1) * 5,
				(random.nextInt(48) + 1) * 5, (random.nextInt(48) + 1) * 5,
				(random.nextInt(48) + 1) * 5, (random.nextInt(48) + 1) * 5,
				(random.nextInt(48) + 1) * 5 };
	}

	public static void main(String[] args) {
		int N = Integer.parseInt(args[0]);
		ParallelSolutionFinder solver = new ParallelSolutionFinder();

		List<SolutionOptimizer> runnerPool = new ArrayList<SolutionOptimizer>();

		for (int threadNum = 0; threadNum < numThreads; threadNum++) {
			SolutionOptimizer runner = new SolutionOptimizer(solver, N);
			runnerPool.add(runner);
			runner.start();
		}

		Timer timer = new Timer();
		TimerTask collectBestSolutionFromAllThreads = new SolutionCollector(
				solver, runnerPool);
		timer.schedule(collectBestSolutionFromAllThreads, 115 * 1000 * 1000);
		
		System.out.println(solver.getBestDenominations());
	}
}
