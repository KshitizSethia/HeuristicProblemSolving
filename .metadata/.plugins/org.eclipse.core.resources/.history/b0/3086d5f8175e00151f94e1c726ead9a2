package exactChange;

import common.Helper;
import common.InvalidDenominationsException;

public class ExactChangeCalculator {

	protected int[] results;

	ExactChangeCalculator() {
		results = new int[Helper.PENCES_IN_POUND];
		resetCosts();
	}

	final void resetCosts() {
		for (int index = results.length - 1; index >= 0; index--) {
			results[index] = Helper.INF;
		}
	}

	final void calculateCostsForDenominations(int[] denominations) {
		for (int denomination : denominations) {
			results[denomination] = 1;
		}

		calculateResult(results.length - 1, denominations);
	}

	/**
	 * 
	 * @return ignore index 0
	 */
	private final int[] getCosts() {
		return results;
	}

	final float getCostGivenN(float N) {
		// todo: get float array to save conversion time
		float cost = 0;
		for (int result : results) {
			cost += result;
		}
		if (N > 1.0) {
			float penalty = 0.0f;
			float n = N - 1.0f;
			for (int index = MULT_OF; index < PENCES_IN_POUND; index += MULT_OF) {
				penalty += results[index];
			}
			penalty *= n;
			cost += penalty;
		}
		return cost;
	}

	private final int calculateResult(int index, int[] denominations) {
		if (index < 1) {
			return Helper.INF;
		}

		if (results[index] == INF) {
			// TODO: never try denomination bigger than parent call's
			for (int denomination : denominations) {
				if (denomination <= index) {
					int costWithThisDenomination = calculateResult(index
							- denomination, denominations) + 1;
					if (costWithThisDenomination < results[index]) {
						// better result found
						results[index] = costWithThisDenomination;
					}
				}
			}
			// TODO: comment this when competing
			if (results[index] == INF) {
				throw new InvalidDenominationsException();
			}
		}
		return results[index];
	}
}
